#!/usr/bin/env python3

import argparse
import re
import sys
from pathlib import Path
import tomllib

# Unchanged: still defines the valid characters for a package name itself
NAME_CHARS = r"[A-Za-z0-9._-]+"

def pep503_normalize(name: str) -> str:
    # PEP 503 normalization: lowercase, collapse -_. to single hyphen
    return re.sub(r"[-_.]+", "-", name).lower()

def extract_dist_name(spec: str) -> str:
    # PEP 508-ish: take the leading dist name before markers/specifiers
    # MODIFIED: The regex now supports extras like `package[extra]`
    m = re.match(rf"^\s*({NAME_CHARS}(?:\[.*?\])?)", spec)
    if not m:
        raise ValueError(f"Cannot extract package name from: {spec!r}")
    return m.group(1)

def load_explicit_dependencies(pyproject_path: Path) -> list[str]:
    data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
    try:
        deps = data["project"]["dependencies"]
    except KeyError as e:
        raise SystemExit("No [project.dependencies] found in pyproject.toml") from e
    names = [extract_dist_name(d) for d in deps]
    return names

def load_lock_versions(uvlock_path: Path) -> dict[str, str]:
    # uv.lock is TOML with [[package]] tables containing name/version
    content = uvlock_path.read_text(encoding="utf-8")
    doc = tomllib.loads(content)
    pkgs = doc.get("package", [])
    mapping: dict[str, str] = {}
    for p in pkgs:
        name = pep503_normalize(p["name"])
        ver = p["version"]
        mapping[name] = ver
    return mapping

def freeze_specs(explicit_names: list[str], lockmap: dict[str, str]) -> list[str]:
    frozen = []
    missing = []
    for raw in explicit_names:
        # MODIFIED: Extract the base name (without extras) for lock file lookup,
        # but keep the raw name (with extras) for the final output string.
        base_name_match = re.match(rf"^({NAME_CHARS})", raw)
        if not base_name_match:
            # This should not happen with valid input, but is good practice
            missing.append(raw)
            continue

        base_name = base_name_match.group(1)
        norm = pep503_normalize(base_name)
        ver = lockmap.get(norm)

        if ver:
            # Use the original `raw` name, which includes extras
            frozen.append(f"{raw}=={ver}")
        else:
            missing.append(raw)
    if missing:
        print(
            "Warning: not found in uv.lock â†’ " + ", ".join(missing),
            file=sys.stderr,
        )
    return frozen

def rewrite_pyproject_dependencies(src_text: str, items: list[str]) -> str:
    """
    Replace the array assigned to project.dependencies with given items (strings).
    Tries to preserve indentation and surrounding formatting.
    Assumes the closing bracket is on its own line (typical layout).
    """
    pattern = re.compile(
        r"""(?mx)
        ^(?P<indent>\s*)dependencies\s*=\s*\[
        (?P<body>.*?)
        ^(?P=indent)\]
        """,
        re.DOTALL,
    )

    def replacement(m: re.Match) -> str:
        indent = m.group("indent")
        inner_indent = indent + "  " # Use spaces for indentation consistency
        lines = [f'{inner_indent}"{spec}",' for spec in items]
        body = "\n".join(lines) + ("\n" if lines else "")
        return f"{indent}dependencies = [\n{body}{indent}]"

    # Scope to [project] table to avoid false positives
    proj_pat = re.compile(r"(?ms)^\[project\](.*?)(?=^\[|\Z)")
    mproj = proj_pat.search(src_text)
    if not mproj:
        raise SystemExit("No [project] table found in pyproject.toml text.")
    start, end = mproj.span()
    segment = src_text[start:end]
    new_segment, n = pattern.subn(replacement, segment, count=1)
    if n == 0:
        raise SystemExit("Could not locate a 'dependencies = [ ... ]' array to rewrite.")
    return src_text[:start] + new_segment + src_text[end:]

def main():
    ap = argparse.ArgumentParser(
        description="Freeze or strip explicit [project.dependencies] using uv.lock"
    )
    ap.add_argument("pyproject", nargs="?", default="pyproject.toml")
    ap.add_argument("uvlock", nargs="?", default="uv.lock")
    ap.add_argument(
        "--mode",
        choices=["freeze", "strip"],
        default="freeze",
        help="freeze: write name==version from uv.lock; strip: keep only bare package names",
    )
    ap.add_argument(
        "--write",
        action="store_true",
        help="Modify pyproject.toml in place (rewrite [project.dependencies])",
    )
    args = ap.parse_args()

    py = Path(args.pyproject)
    lock = Path(args.uvlock)

    if not py.exists():
        ap.error(f"File not found: {py}")
    if args.mode == "freeze" and not lock.exists():
        ap.error(f"uv.lock not found: {lock}")

    # read explicit names
    explicit_names = load_explicit_dependencies(py)

    if args.mode == "freeze":
        lockmap = load_lock_versions(lock)
        result_items = freeze_specs(explicit_names, lockmap)  # e.g., ["pkg[extra]==1.2.3", ...]
        # Print result lines
        for line in result_items:
            print(line)
        if args.write:
            src = py.read_text(encoding="utf-8")
            dst = rewrite_pyproject_dependencies(src, result_items)
            py.write_text(dst, encoding="utf-8")
            print(f"\nWrote pins into: {py}", file=sys.stderr)

    else:  # strip
        # Just the names
        for name in explicit_names:
            print(name)
        if args.write:
            src = py.read_text(encoding="utf-8")
            # In strip mode, rewrite deps array with only bare names (with extras)
            dst = rewrite_pyproject_dependencies(src, explicit_names)
            py.write_text(dst, encoding="utf-8")
            print(f"\nStripped versions in: {py}", file=sys.stderr)

if __name__ == "__main__":
    main()
